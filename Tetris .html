<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>俄罗斯方块</title>
  <style>
    body {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background-color: #333;
      color: #fff;
      font-family: Arial, sans-serif;
    }
    canvas {
      border: 2px solid #fff;
      background-color: #000;
    }
    button {
      margin: 10px;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
    }
    .controls {
      margin-top: 20px;
    }
    .score {
      margin-top: 20px;
      font-size: 24px;
    }
  </style>
</head>
<body>
  <h1>俄罗斯方块</h1>
  <canvas id="tetris" width="300" height="600"></canvas>
  <div class="score">得分: <span id="score">0</span></div>
  <div class="controls">
    <button id="startButton">开始</button>
    <button id="pauseButton">暂停</button>
  </div>

  <script>
    const canvas = document.getElementById('tetris');
    const context = canvas.getContext('2d');

    const ROWS = 20;
    const COLS = 10;
    const BLOCK_SIZE = 30;

    // Game state
    let board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
    let currentTetromino = null;
    let isPaused = false;
    let score = 0;
    let speed = 500; // Initial speed in milliseconds
    let lastTime = 0;

    // Tetrominoes
    const TETROMINOES = {
      I: [[0,0,0,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0]],
      O: [[0,0,0,0],[0,1,1,0],[0,1,1,0],[0,0,0,0]],
      T: [[0,0,0],[0,1,0],[1,1,1]],
      S: [[0,0,0],[0,1,1],[1,1,0]],
      Z: [[0,0,0],[1,1,0],[0,1,1]],
      J: [[0,0,0],[1,0,0],[1,1,1]],
      L: [[0,0,0],[0,0,1],[1,1,1]],
    };

    // Colors for tetrominoes
    const COLORS = ['#FF5733', '#33FF57', '#3357FF', '#F3FF33', '#FF33F3', '#33FFF6', '#F633FF'];

    // Pre-render blocks for faster drawing
    let blockImage = document.createElement('canvas');
    let blockCtx = blockImage.getContext('2d');
    blockImage.width = BLOCK_SIZE;
    blockImage.height = BLOCK_SIZE;

function createBlockImage(color, ghost = false) {
  blockCtx.clearRect(0, 0, BLOCK_SIZE, BLOCK_SIZE);
  
  if (ghost) {
    blockCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)'; // 更淡的白色轮廓
    blockCtx.setLineDash([5, 5]); // 虚线边框
    blockCtx.strokeRect(2, 2, BLOCK_SIZE - 4, BLOCK_SIZE - 4);
  } else {
    blockCtx.fillStyle = color;
    blockCtx.fillRect(0, 0, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
    blockCtx.strokeStyle = '#000';
    blockCtx.strokeRect(0, 0, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
  }

  return blockImage;
}


    // Double buffering
    let offscreenCanvas = document.createElement('canvas');
    offscreenCanvas.width = canvas.width;
    offscreenCanvas.height = canvas.height;
    let offscreenCtx = offscreenCanvas.getContext('2d');

    // Draw a single block using pre-rendered images
    function drawBlock(x, y, color, ghost = false) {
      offscreenCtx.drawImage(createBlockImage(color, ghost), x * BLOCK_SIZE, y * BLOCK_SIZE);
    }

    // Clear a single block
    function clearBlock(x, y) {
      offscreenCtx.clearRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
    }

    // Render the entire game board and tetromino
    function render() {
      offscreenCtx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw board
      board.forEach((row, y) => {
        row.forEach((cell, x) => {
          if (cell) {
            drawBlock(x, y, cell.color);
          }
        });
      });

      // Draw current tetromino
      if (currentTetromino) {
        // Draw ghost tetromino
        let ghostY = getGhostPosition();
        currentTetromino.shape.forEach((row, dy) => {
          row.forEach((value, dx) => {
            if (value) {
              drawBlock(currentTetromino.x + dx, ghostY + dy, currentTetromino.color, true);
            }
          });
        });

        // Draw actual tetromino
        currentTetromino.shape.forEach((row, dy) => {
          row.forEach((value, dx) => {
            if (value) {
              drawBlock(currentTetromino.x + dx, currentTetromino.y + dy, currentTetromino.color);
            }
          });
        });
      }
      
      context.clearRect(0, 0, canvas.width, canvas.height);
      context.drawImage(offscreenCanvas, 0, 0);
    }

    // Find ghost position
    function getGhostPosition() {
      let ghostY = currentTetromino.y;
      while (!checkCollisionAt(ghostY + 1)) {
        ghostY++;
      }
      return ghostY;
    }

    // Check for collisions at a specific y position
    function checkCollisionAt(y) {
      return currentTetromino.shape.some((row, dy) =>
        row.some((value, dx) => {
          let x = currentTetromino.x + dx;
          let testY = y + dy;
          return value && (testY >= ROWS || x < 0 || x >= COLS || (board[testY] && board[testY][x] !== 0));
        })
      );
    }

    // Move the tetromino down
    function moveDown() {
      // Clear old position before moving
      if (currentTetromino) {
        currentTetromino.shape.forEach((row, dy) => {
          row.forEach((value, dx) => {
            if (value) {
              clearBlock(currentTetromino.x + dx, currentTetromino.y + dy);
            }
          });
        });
      }
      
      currentTetromino.y++;
      if (checkCollision()) {
        currentTetromino.y--;
        placeTetromino();
        spawnNewTetromino();
      }
      render();
    }

    // Check for collisions
    function checkCollision() {
      return checkCollisionAt(currentTetromino.y);
    }

    // Place tetromino on the board
    function placeTetromino() {
      currentTetromino.shape.forEach((row, dy) => {
        row.forEach((value, dx) => {
          if (value) {
            board[currentTetromino.y + dy][currentTetromino.x + dx] = { color: currentTetromino.color };
          }
        });
      });
      clearLines();
      render();
    }

    // Clear completed lines and update score
    function clearLines() {
      let linesCleared = 0;
      for (let y = ROWS - 1; y >= 0; y--) {
        if (board[y].every(cell => cell !== 0)) {
          board.splice(y, 1);
          board.unshift(Array(COLS).fill(0));
          linesCleared++;
          y++; // Re-check the same line after shifting
        }
      }
      updateScore(linesCleared);
    }

    // Update score and adjust speed
    function updateScore(linesCleared) {
      score += linesCleared * 100;
      document.getElementById('score').textContent = score;
      adjustSpeed();
    }

    // Adjust speed based on score
    function adjustSpeed() {
      speed = Math.max(100, 500 - Math.floor(score / 1000) * 100);
    }

    // Spawn a new tetromino
    function spawnNewTetromino() {
      const keys = Object.keys(TETROMINOES);
      const randomKey = keys[Math.floor(Math.random() * keys.length)];
      
      currentTetromino = {
        shape: TETROMINOES[randomKey],
        x: Math.floor(COLS / 2) - Math.floor(TETROMINOES[randomKey][0].length / 2),
        y: 0,
        color: COLORS[Math.floor(Math.random() * COLORS.length)],
      };
      
      if (checkCollision()) {
        alert('Game Over!');
        resetGame();
      } else {
        render();
      }
    }

    // Reset the game
    function resetGame() {
      board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
      currentTetromino = null;
      isPaused = false;
      score = 0;
      speed = 500;
      document.getElementById('score').textContent = score;
      document.getElementById('startButton').disabled = false;
      document.getElementById('pauseButton').textContent = '暂停';
      render();
    }

    // Rotate tetromino (with wall kick)
    function rotateTetromino() {
      // Clear old position before rotating
      if (currentTetromino) {
        currentTetromino.shape.forEach((row, dy) => {
          row.forEach((value, dx) => {
            if (value) {
              clearBlock(currentTetromino.x + dx, currentTetromino.y + dy);
            }
          });
        });
      }
      
      const rotated = currentTetromino.shape[0].map((_, i) =>
        currentTetromino.shape.map(row => row[i]).reverse()
      );
      const prevShape = currentTetromino.shape;
      
      currentTetromino.shape = rotated;
      if (checkCollision()) {
        currentTetromino.shape = prevShape;
      }
      render();
    }

    // Key controls
    document.addEventListener('keydown', event => {
      if (isPaused) return;
      switch(event.key) {
        case 'ArrowLeft': 
          if (canMove(-1, 0)) { 
            // Clear old position before moving
            currentTetromino.shape.forEach((row, dy) => {
              row.forEach((value, dx) => {
                if (value) {
                  clearBlock(currentTetromino.x + dx, currentTetromino.y + dy);
                }
              });
            });
            currentTetromino.x--; 
            render(); 
          }
          break;
        case 'ArrowRight': 
          if (canMove(1, 0)) { 
            // Clear old position before moving
            currentTetromino.shape.forEach((row, dy) => {
              row.forEach((value, dx) => {
                if (value) {
                  clearBlock(currentTetromino.x + dx, currentTetromino.y + dy);
                }
              });
            });
            currentTetromino.x++; 
            render(); 
          }
          break;
        case 'ArrowDown': 
          moveDown(); 
          break;
        case 'ArrowUp': 
          rotateTetromino(); 
          break;
      }
    });

    // Pre-check if tetromino can move in a given direction
    function canMove(dx, dy) {
      return currentTetromino.shape.every((row, y) =>
        row.every((value, x) => 
          value === 0 || !((x + currentTetromino.x + dx < 0 || 
                            x + currentTetromino.x + dx >= COLS || 
                            y + currentTetromino.y + dy >= ROWS || 
                            (board[y + currentTetromino.y + dy] && board[y + currentTetromino.y + dy][x + currentTetromino.x + dx] !== 0)))
        )
      );
    }

    // Start the game
    document.getElementById('startButton').addEventListener('click', () => {
      resetGame();
      spawnNewTetromino();
      document.getElementById('startButton').disabled = true;
      gameLoop();
    });

    // Pause the game
    document.getElementById('pauseButton').addEventListener('click', () => {
      isPaused = !isPaused;
      document.getElementById('pauseButton').textContent = isPaused ? '继续' : '暂停';
    });

    // Game loop with requestAnimationFrame
    function gameLoop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const deltaTime = timestamp - lastTime;

      if (!isPaused && deltaTime >= speed) {
        moveDown();
        lastTime = timestamp;
      }
      
      requestAnimationFrame(gameLoop);
    }
  </script>
</body>
</html>
